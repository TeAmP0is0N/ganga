#!/usr/bin/env python

from __future__ import print_function
import shutil
import os
import time
import popen2
import glob
import mimetypes
import sys
import tarfile
import subprocess
import os,os.path,shutil,tempfile

if len(sys.argv)>1 and sys.argv[1] == 'subprocess':
    os.setsid()

###INLINEMODULES###
###INLINEHOSTNAMEFUNCTION###

input_sandbox = ###INPUT_SANDBOX###
sharedoutputpath = ###SHAREDOUTPUTPATH###
outputpatterns = ###OUTPUTPATTERNS###
execmd = ###APPSCRIPTPATH###
environment = ###ENVIRONMENT###

# jobid is a string
jobid = ###JOBID###
Backend = ###BACKEND###

###PREEXECUTE###

def flush_file(f):
    f.flush()
    os.fsync(f.fileno()) #this forces a global flush (cache synchronization on AFS)

def open_file(fname):
    try:
        filehandle=open(fname,'w')
    except IOError as x:
        print('ERROR: not able to write a status file: ', fname)
        print('ERROR: ',x)
        raise
    return filehandle

def failurereport(filehandle, message):
    errfile = open('stderr', 'w' )
    errfile.close()
    print('EXITCODE: %d' % -9999, file=filehandle)
    print('FAILED: %s'%time.strftime('%a %b %d %H:%M:%S %Y'), file=filehandle)
    print('PROBLEM STARTING THE APPLICATION SCRIPT: \'%s\' \'%s\''%(execmd,str(x)), file=filehandle)
    print('FILES FOUND ARE: %s' % os.listdir('.'), file=filehandle)
    filehandle.close()
    sys.exit()

heartbeatfilename = os.path.join(sharedoutputpath,'__heartbeat__')
heartbeatfile=open_file(heartbeatfilename)


line='START: '+ time.strftime('%a %b %d %H:%M:%S %Y',time.gmtime(time.time())) + os.linesep
if Backend == "BATCH":
    try:
        line+='PID: ' + os.getenv('###JOBIDNAME###') + os.linesep
        line+='QUEUE: ' + os.getenv('###QUEUENAME###') + os.linesep
        line+='ACTUALCE: ' + hostname() + os.linesep
    except:
        pass

heartbeatfile.writelines(line)
flush_file(heartbeatfile)

if Backend == "LOCAL":
    workdir = ###WORKDIR###
    if not os.path.exists(workdir):
        os.makedirs(workdir)
    os.chdir(workdir)


for f in input_sandbox:
    if mimetypes.guess_type(f)[1] in ['gzip', 'bzip2']:
        getPackedInputSandbox(f)
    else:
        shutil.copy(f, os.path.join(os.getcwd(), os.path.basename(f)))

# -- END OF MOVED CODE BLOCK


#get input files
###DOWNLOADINPUTFILES###

# create inputdata list
###CREATEINPUTDATALIST###

gangadir = ###GANGADIR###
sys.path.insert(0,gangadir)
sys.path.insert(0,os.path.join(os.getcwd(),PYTHON_DIR))

runenv = os.environ.copy()
for key,value in environment.items():
    runenv[key] = value

if Backend == "BATCH":
    outfile = os.dup(sys.stdout.fileno())
    errorfile = os.dup(sys.stderr.fileno())

    print("--- GANGA APPLICATION OUTPUT BEGIN ---", file=sys.stdout)
    print("--- GANGA APPLICATION ERROR BEGIN ---", file=sys.stderr)
    flush_file(sys.stdout)
    flush_file(sys.stderr)

elif Backend == "LOCAL":
    outfile=open('stdout','w')
    errorfile=open('stderr','w')

sys.stdout=open('./__syslog__','w')
sys.stderr=sys.stdout

###VIRTUALIZATION###

try:
    child = subprocess.Popen(execmd, shell=False, stdout=outfile, stderr=errorfile, env=runenv)
except OSError as x:
    failurereport(heartbeatfile, 'PROBLEM STARTING THE APPLICATION SCRIPT: \'%s\' \'%s\''%(execmd,str(x)))

print('PID: %d'%child.pid, file=heartbeatfile)
flush_file(heartbeatfile)

result = -1

try:
    while 1:
        result = child.poll()
        if result is not None:
            break
        heartbeatfile.write('.')
        flush_file(heartbeatfile)
        time.sleep(0.3)

except Exception as x:
    print('ERROR: %s'%str(x))
finally:
    pass
    sys.stdout=sys.__stdout__
    sys.stderr=sys.__stderr__

flush_file(outfile)
flush_file(errorfile)


if Backend=="BATCH":
    flush_file(sys.stdout)
    flush_file(sys.stderr)
    print("--- GANGA APPLICATION OUTPUT END ---", file=sys.stdout)

try:
    filefilter
except:
    filefilter = None

from files import multi_glob, recursive_copy

createOutputSandbox(outputpatterns,filefilter,sharedoutputpath)

def printError(message):
    print(message, file=errorfile)
    flush_file(errorfile)

def printInfo(message):
    print(message, file=outfile)
    flush_file(errorfile)


###OUTPUTUPLOADSPOSTPROCESSING###

if Backend=="BATCH":
    print("--- GANGA APPLICATION ERROR END ---", file=sys.stderr)

###OUTPUTSANDBOXPOSTPROCESSING###

outfile.close()
errorfile.close()


###POSTEXECUTE###


line='EXITCODE: ' + repr(result) + os.linesep
line+='STOP: '+time.strftime('%a %b %d %H:%M:%S %Y',time.gmtime(time.time())) + os.linesep
heartbeatfile.writelines(line)
heartbeatfile.close()


if Backend=="BATCH":
    # Remove the file path
    os.unlink(heartbeatfilename)

sys.exit()
